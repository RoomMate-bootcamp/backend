# ./run.py
# run.py
import asyncio
import logging
from bot.main import start_bot

if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    # Run the bot
    asyncio.run(start_bot())

# ./alembic.ini
# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the
# "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to alembic/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = postgresql+psycopg://denisfotiev:@localhost:5432/dodo-certificate-db


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

# ./Dockerfile
FROM python:3.12.3-slim-bullseye as base

ENV PYTHONUNBUFFERED 1
WORKDIR /build

RUN apt-get update && apt-get install -y gcc

# Create requirements.txt file
FROM base as poetry
RUN pip install poetry==1.8.2
COPY poetry.lock pyproject.toml ./
RUN poetry export -o /requirements.txt --without-hashes
RUN pip install asyncpg
FROM base as common
COPY --from=poetry /requirements.txt .
# Create venv, add it to path and install requirements
RUN python -m venv /venv
ENV PATH="/venv/bin:$PATH"
RUN pip install -r requirements.txt

# Install uvicorn server
RUN pip install uvicorn[standard]

# Copy the rest of app
COPY src src
COPY .env .env
COPY alembic alembic
COPY alembic.ini .
COPY pyproject.toml .
COPY init.sh .


# Create new user to run app process as unprivilaged user
RUN addgroup --gid 1001 --system uvicorn && \
    adduser --gid 1001 --shell /bin/false --disabled-password --uid 1001 uvicorn

# Run init.sh script then start uvicorn
RUN chown -R uvicorn:uvicorn /build
CMD bash init.sh && \
    runuser -u uvicorn -- /venv/bin/uvicorn src.main:app --app-dir /build --host 0.0.0.0 --port 8010 --workers 2 --loop uvloop
EXPOSE 8010

# ./init.sh
#!/bin/bash

echo "Run migrations"
alembic upgrade head

# ./README.md
# backend

# ./.env
DB_URL=postgresql+psycopg://denisfotiev:@localhost:5432/bootcamp-postgres
DB_ECHO=FALSE
SECRET_KEY=your-secret-key
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=120
YANDEX_FOLDER_ID=b1gug7c74crq38i2spt2
YANDEX_API_KEY=AQVN39cHKAHU02Gp0TFQB4GVd7MdFVzo8i4PXuHU
TELEGRAM_BOT_TOKEN=8075974820:AAGxmuuKKxFE89i5YE2b7SpOzTbA3k-HhVs


# ./bot/config.py
import os
from dotenv import load_dotenv

load_dotenv()

BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
DB_URL = os.getenv("DB_URL")
WEBHOOK_URL = os.getenv("WEBHOOK_URL", "")
WEBHOOK_PATH = os.getenv("WEBHOOK_PATH", "/webhook")
WEBAPP_HOST = os.getenv("WEBAPP_HOST", "localhost")
WEBAPP_PORT = os.getenv("WEBAPP_PORT", 8000)

YANDEX_FOLDER_ID = os.getenv("YANDEX_FOLDER_ID")
YANDEX_API_KEY = os.getenv("YANDEX_API_KEY")


# ./bot/keyboards/search_kb.py
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

def get_roommate_keyboard(roommate_id) -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="👎 Пропустить", callback_data=f"roommate_skip_{roommate_id}"),
                InlineKeyboardButton(text="👍 Нравится", callback_data=f"roommate_like_{roommate_id}")
            ],
            [
                InlineKeyboardButton(text="📊 Проверить совместимость", callback_data=f"compatibility_{roommate_id}")
            ]
        ]
    )
    return keyboard

def get_compatibility_keyboard(roommate_id) -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="👎 Пропустить", callback_data=f"roommate_skip_{roommate_id}"),
                InlineKeyboardButton(text="👍 Нравится", callback_data=f"roommate_like_{roommate_id}")
            ],
            [
                InlineKeyboardButton(text="🔙 Назад к профилю", callback_data=f"back_to_profile_{roommate_id}")
            ]
        ]
    )
    return keyboard

# ./bot/keyboards/start_kb.py
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

def get_start_keyboard() -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="🔑 Авторизация", callback_data="auth_login"),
                InlineKeyboardButton(text="📝 Регистрация", callback_data="auth_register")
            ],
        ]
    )
    return keyboard

def get_auth_keyboard() -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="🔑 Авторизация", callback_data="auth_login"),
                InlineKeyboardButton(text="📝 Регистрация", callback_data="auth_register")
            ],
        ]
    )
    return keyboard

# ./bot/keyboards/main_kb.py
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

def get_main_menu_keyboard() -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="👤 Мой профиль", callback_data="show_profile")
            ],
            [
                InlineKeyboardButton(text="🔍 Поиск соседей", callback_data="start_search")
            ],
            [
                InlineKeyboardButton(text="🔄 Мои совпадения", callback_data="show_matches")
            ],
            [
                InlineKeyboardButton(text="🤖 ИИ-помощник", callback_data="start_ai_chat")
            ]
        ]
    )
    return keyboard

# ./bot/keyboards/matches_kb.py
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton


def get_matches_keyboard(matches) -> InlineKeyboardMarkup:
    keyboard = []

    for match in matches:
        roommate = match.get("roommate", {})
        name = roommate.get("name", "Неизвестно")
        keyboard.append([
            InlineKeyboardButton(text=f"👤 {name}", callback_data=f"match_{match.get('id')}")
        ])

    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def get_match_actions_keyboard(match_id) -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="💬 Связаться", callback_data=f"contact_{match_id}")
            ],
            [
                InlineKeyboardButton(text="❌ Удалить совпадение", callback_data=f"delete_match_{match_id}")
            ],
            [
                InlineKeyboardButton(text="🔙 Назад к совпадениям", callback_data="back_to_matches")
            ]
        ]
    )
    return keyboard


def get_main_menu_keyboard() -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="👤 Мой профиль", callback_data="show_profile")
            ],
            [
                InlineKeyboardButton(text="🔍 Поиск соседей", callback_data="start_search")
            ],
            [
                InlineKeyboardButton(text="🔄 Мои совпадения", callback_data="show_matches")
            ],
            [
                InlineKeyboardButton(text="🤖 ИИ-помощник", callback_data="start_ai_chat")
            ]
        ]
    )
    return keyboard

# ./bot/keyboards/__init__.py


# ./bot/keyboards/profile_kb.py
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton



def get_gender_keyboard() -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="Мужской", callback_data="gender_male"),
                InlineKeyboardButton(text="Женский", callback_data="gender_female")
            ],
            [
                InlineKeyboardButton(text="Другой", callback_data="gender_other")
            ]
        ]
    )
    return keyboard


def get_interests_keyboard(selected_interests=[]) -> InlineKeyboardMarkup:
    interests = [
        "Спорт", "Музыка", "Кино", "Литература", "Технологии",
        "Путешествия", "Кулинария", "Игры", "Искусство", "Фотография"
    ]

    keyboard = []

    for i in range(0, len(interests), 2):
        row = []
        for j in range(2):
            if i + j < len(interests):
                interest = interests[i + j]
                prefix = "✅ " if interest in selected_interests else ""
                row.append(InlineKeyboardButton(
                    text=f"{prefix}{interest}",
                    callback_data=f"interest_{interest}"
                ))
        keyboard.append(row)

    keyboard.append([InlineKeyboardButton(text="✅ Готово", callback_data="interests_done")])

    return InlineKeyboardMarkup(inline_keyboard=keyboard)

# bot/keyboards/profile_kb.py
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

def get_profile_keyboard() -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="✏️ Имя", callback_data="edit_name"),
                InlineKeyboardButton(text="🔢 Возраст", callback_data="edit_age"),
                InlineKeyboardButton(text="👤 Пол", callback_data="edit_gender")
            ],
            [
                InlineKeyboardButton(text="💼 Профессия", callback_data="edit_occupation"),
                InlineKeyboardButton(text="🧹 Чистоплотность", callback_data="edit_cleanliness")
            ],
            [
                InlineKeyboardButton(text="😴 Режим сна", callback_data="edit_sleep"),
                InlineKeyboardButton(text="💰 Бюджет", callback_data="edit_budget")
            ],
            [
                InlineKeyboardButton(text="📍 Район", callback_data="edit_location"),
                InlineKeyboardButton(text="🚬 Курение", callback_data="edit_smoking")
            ],
            [
                InlineKeyboardButton(text="🐱 Животные", callback_data="edit_pets"),
                InlineKeyboardButton(text="👨‍👩‍👧‍👦 Интересы", callback_data="edit_interests")
            ],
            [
                InlineKeyboardButton(text="🏛️ ВУЗ/Город учебы", callback_data="edit_study_location"),
                InlineKeyboardButton(text="📚 Специальность", callback_data="edit_study_program")
            ],
            [
                InlineKeyboardButton(text="🏠 Предпочтения по жилью", callback_data="edit_accommodation"),
                InlineKeyboardButton(text="📱 Ник в Telegram", callback_data="edit_telegram_username")
            ],
            [
                InlineKeyboardButton(text="📝 О себе", callback_data="edit_bio")
            ],
            [
                InlineKeyboardButton(text="🔍 Поиск соседей", callback_data="start_search")
            ],
            [
                InlineKeyboardButton(text="🔙 Вернуться в меню", callback_data="return_to_menu")
            ]
        ]
    )
    return keyboard

def get_accommodation_keyboard() -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="🏢 Квартира", callback_data="accommodation_apartment"),
            ],
            [
                InlineKeyboardButton(text="🏨 Общежитие", callback_data="accommodation_dormitory"),
            ],
            [
                InlineKeyboardButton(text="🔄 Не имеет значения", callback_data="accommodation_no_preference"),
            ]
        ]
    )
    return keyboard

# ./bot/keyboards/ai_chat_kb.py
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton


def get_ai_chat_keyboard() -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="❌ Завершить диалог с ИИ", callback_data="exit_ai_chat")
            ]
        ]
    )
    return keyboard

# ./bot/middlewares/auth.py
from typing import Callable, Dict, Any, Awaitable

from aiogram import BaseMiddleware
from aiogram.types import TelegramObject
from aiogram.fsm.context import FSMContext


class AuthMiddleware(BaseMiddleware):
    async def __call__(
            self,
            handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
            event: TelegramObject,
            data: Dict[str, Any]
    ) -> Any:
        # Get FSM context from data
        fsm_context: FSMContext = data.get("state")

        if fsm_context:
            # Get user data from FSM storage
            user_data = await fsm_context.get_data()

            # Add token to data if available
            if "token" in user_data:
                data["token"] = user_data["token"]

        # Continue processing
        return await handler(event, data)

# ./bot/middlewares/__init__.py
from aiogram import Dispatcher

from bot.middlewares.auth import AuthMiddleware

def setup_middlewares(dp: Dispatcher):
    dp.update.middleware(AuthMiddleware())


# ./bot/__init__.py
from bot.main import start_bot

# ./bot/states/search_states.py
from aiogram.fsm.state import State, StatesGroup

class SearchStates(StatesGroup):
    browsing = State()
    compatibility_check = State()

# ./bot/states/profile_states.py
from aiogram.fsm.state import State, StatesGroup


class ProfileStates(StatesGroup):
    edit_name = State()
    edit_age = State()
    edit_gender = State()
    edit_occupation = State()
    edit_bio = State()
    edit_interests = State()
    edit_cleanliness = State()
    edit_sleep = State()
    edit_budget = State()
    edit_location = State()
    edit_smoking = State()
    edit_pets = State()

    # New education and accommodation states
    edit_study_location = State()
    edit_study_program = State()
    edit_accommodation = State()
    edit_telegram_username = State()

# ./bot/states/__init__.py


# ./bot/states/ai_chat_states.py
from aiogram.fsm.state import State, StatesGroup

class AIChatState(StatesGroup):
    chatting = State()

# ./bot/states/auth_states.py
from aiogram.fsm.state import State, StatesGroup

class AuthStates(StatesGroup):
    get_username = State()
    get_email = State()
    get_password = State()
    login_username = State()
    login_password = State()
    profile_setup = State()


# ./bot/main.py
# bot/main.py (add to existing file)
import asyncio
import logging
from aiogram import Bot, Dispatcher
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.strategy import FSMStrategy

from bot.handlers import register_all_handlers
from bot.middlewares import setup_middlewares
from bot.config import BOT_TOKEN, WEBHOOK_URL, WEBHOOK_PATH, WEBAPP_HOST, WEBAPP_PORT
from bot.services.database import init_db
from bot.handlers.notifications import check_notifications
from src.core.database import postgres_helper
from sqlalchemy import select, text
from src.core.database import User


async def periodic_notification_check(bot: Bot):
    """Periodically check for new notifications for all users"""
    while True:
        try:
            logging.info("Running periodic notification check")

            # Get all users with telegram_id in user_metadata
            async with postgres_helper.session_factory() as session:
                # Get all users that have a telegram_id in their metadata
                query = text("SELECT id FROM users WHERE user_metadata->>'telegram_id' IS NOT NULL")
                result = await session.execute(query)
                users = result.fetchall()

                for user_row in users:
                    user_id = user_row[0]
                    await check_notifications(user_id, bot)

            # Run every 60 seconds
            await asyncio.sleep(60)
        except Exception as e:
            logging.error(f"Error in periodic notification check: {e}")
            await asyncio.sleep(60)  # Still wait before retrying


async def start_bot():
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    # Initialize bot and dispatcher
    bot = Bot(token=BOT_TOKEN)
    storage = MemoryStorage()
    dp = Dispatcher(storage=storage, fsm_strategy=FSMStrategy.CHAT)

    # Setup middlewares
    setup_middlewares(dp)

    # Register all handlers
    register_all_handlers(dp)

    # Initialize database connection
    await init_db()

    # Start periodic notification checker
    asyncio.create_task(periodic_notification_check(bot))

    # Start polling
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot, allowed_updates=dp.resolve_used_update_types())


if __name__ == "__main__":
    asyncio.run(start_bot())

# ./bot/handlers/matches.py
from aiogram import Router, F, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from sqlalchemy import select, or_

from bot.keyboards.matches_kb import get_matches_keyboard, get_match_actions_keyboard
from src.core.database import User, postgres_helper, Match

router = Router()


async def show_matches(message: types.Message, state: FSMContext):
    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    if not user_id:
        await message.answer("Пожалуйста, используйте /start для начала работы с ботом.")
        return

    # Get matches
    async with postgres_helper.session_factory() as session:
        query = select(Match).where(
            or_(
                Match.user1_id == user_id,
                Match.user2_id == user_id
            )
        )
        result = await session.execute(query)
        matches = result.scalars().all()

        matches_data = []
        for match in matches:
            # Get other user
            other_id = match.user2_id if match.user1_id == user_id else match.user1_id
            other_user = await session.get(User, other_id)

            if other_user:
                matches_data.append({
                    "id": match.id,
                    "timestamp": match.timestamp,
                    "roommate": {
                        "id": other_user.id,
                        "name": other_user.name,
                        "username": other_user.username
                    }
                })

    if not matches_data:
        await message.answer("У вас пока нет совпадений. Используйте /search, чтобы найти потенциальных соседей.")
        return

    await message.answer("🔄 Ваши совпадения:", reply_markup=get_matches_keyboard(matches_data))


async def show_match_details(callback: types.CallbackQuery, state: FSMContext):
    match_id = int(callback.data.split("_")[1])
    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    async with postgres_helper.session_factory() as session:
        match = await session.get(Match, match_id)

        if not match:
            await callback.message.answer("Совпадение не найдено.")
            await callback.answer()
            return

        # Get other user
        other_id = match.user2_id if match.user1_id == user_id else match.user1_id
        roommate = await session.get(User, other_id)

        if not roommate:
            await callback.message.answer("Пользователь не найден.")
            await callback.answer()
            return

        profile_text = (
            f"👥 *Ваше совпадение*\n\n"
            f"*Имя:* {roommate.name or 'Не указано'}\n"
            f"*Возраст:* {roommate.age or 'Не указано'}\n"
            f"*Пол:* {roommate.gender or 'Не указано'}\n"
            f"*Профессия:* {roommate.occupation or 'Не указано'}\n"
            f"*Уровень чистоплотности:* {roommate.cleanliness_level or 'Не указано'}/5\n"
            f"*Режим сна:* {roommate.sleep_habits or 'Не указано'}\n"
            f"*Бюджет на аренду:* {roommate.rent_budget or 'Не указано'} ₽\n"
            f"*Район поиска:* {roommate.location or 'Не указано'}\n"
            f"*О себе:*\n{roommate.bio or 'Не указано'}\n\n"
            f"*Интересы:*\n{', '.join(roommate.interests or ['Не указано'])}"
        )

        await callback.message.answer(profile_text, reply_markup=get_match_actions_keyboard(match_id))

    await callback.answer()


async def delete_match(callback: types.CallbackQuery, state: FSMContext):
    match_id = int(callback.data.split("_")[1])
    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    async with postgres_helper.session_factory() as session:
        match = await session.get(Match, match_id)

        if not match:
            await callback.message.answer("Совпадение не найдено.")
            await callback.answer()
            return

        # Check if user is part of the match
        if match.user1_id != user_id and match.user2_id != user_id:
            await callback.message.answer("У вас нет прав для удаления этого совпадения.")
            await callback.answer()
            return

        await session.delete(match)
        await session.commit()

        await callback.message.answer("✅ Совпадение удалено.")
        await show_matches(callback.message, state)

    await callback.answer()


def register_matches_handlers(dp):
    dp.include_router(router)

    router.message.register(show_matches, Command("matches"))
    router.callback_query.register(show_match_details, F.data.startswith("match_"))
    router.callback_query.register(delete_match, F.data.startswith("delete_match_"))
    router.callback_query.register(back_to_matches_callback, F.data == "back_to_matches")


async def back_to_matches_callback(callback: types.CallbackQuery, state: FSMContext):
    await callback.answer()
    await show_matches(callback.message, state)


# ./bot/handlers/ai_chat.py
# bot/handlers/ai_chat.py
import asyncio
from aiogram import Router, F, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from sqlalchemy import select

from src.core.database import User, postgres_helper
from src.core.utils.AIMatchingService import ai_matching_service
from bot.states.ai_chat_states import AIChatState
from bot.keyboards.ai_chat_kb import get_ai_chat_keyboard
from bot.keyboards.main_kb import get_main_menu_keyboard
from yandex_cloud_ml_sdk import YCloudML
from bot.config import YANDEX_FOLDER_ID, YANDEX_API_KEY

router = Router()

# Initialize YandexGPT
sdk = YCloudML(
    folder_id=YANDEX_FOLDER_ID,
    auth=YANDEX_API_KEY
)
model = sdk.models.completions('yandexgpt-lite')
model.configure(
    temperature=0.5,
    max_tokens=2000,
)


async def start_ai_chat(message: types.Message, state: FSMContext):
    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    if not user_id:
        await message.answer("Пожалуйста, используйте /start для начала работы с ботом.")
        return

    await message.answer(
        "🤖 Привет! Я ИИ-помощник по бытовым вопросам. "
        "Могу помочь с организацией пространства, уборкой, готовкой, "
        "решением бытовых конфликтов и многим другим. Просто спросите меня о чем угодно!",
        reply_markup=get_ai_chat_keyboard()
    )

    await state.set_state(AIChatState.chatting)


async def exit_ai_chat(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.answer(
        "Вы вышли из режима общения с ИИ-помощником. Что бы вы хотели сделать дальше?",
        reply_markup=get_main_menu_keyboard()
    )
    await callback.answer()


async def process_ai_query(message: types.Message, state: FSMContext):
    current_state = await state.get_state()
    if current_state != "AIChatState:chatting":
        return

    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    if not user_id:
        await message.answer("Пожалуйста, используйте /start для начала работы с ботом.")
        return

    # Get user profile for context
    async with postgres_helper.session_factory() as session:
        user = await session.get(User, user_id)
        if not user:
            await message.answer("Ошибка при получении данных пользователя.")
            return

        # Create profile context
        user_profile = {
            "name": user.name,
            "age": user.age,
            "gender": user.gender,
            "cleanliness_level": user.cleanliness_level,
            "sleep_habits": user.sleep_habits,
            "smoking_preference": user.smoking_preference,
            "pet_preference": user.pet_preference,
            "interests": user.interests or []
        }

    query = message.text

    # Show typing indicator
    await message.bot.send_chat_action(chat_id=message.chat.id, action="typing")

    # Send waiting message
    waiting_msg = await message.answer("⏳ Обдумываю ответ, пожалуйста, подождите...")

    # Start a task to periodically update typing status while waiting for response
    async def keep_typing():
        for _ in range(30):  # Limit to prevent infinite loop
            await message.bot.send_chat_action(chat_id=message.chat.id, action="typing")
            await asyncio.sleep(4)  # Telegram typing indicator lasts ~5 seconds

    typing_task = asyncio.create_task(keep_typing())

    try:
        # Get AI response
        response = await get_ai_response(query, user_profile)

        # Cancel typing indicator
        typing_task.cancel()

        # Delete waiting message
        await waiting_msg.delete()

        # Send the actual response
        await message.answer(response, reply_markup=get_ai_chat_keyboard())
    except Exception as e:
        # Cancel typing indicator
        typing_task.cancel()

        # Update waiting message with error
        await waiting_msg.edit_text(
            f"😕 Произошла ошибка при получении ответа: {str(e)}\n"
            "Пожалуйста, попробуйте еще раз или задайте другой вопрос.",
            reply_markup=get_ai_chat_keyboard()
        )


async def get_ai_response(query: str, user_profile):
    system_prompt = """
    Ты - полезный ассистент по бытовым вопросам для соседей по квартире.
    Ты помогаешь с решением бытовых проблем, организацией пространства, уборкой, 
    готовкой, разрешением конфликтов между соседями по квартире и другими домашними вопросами.
    Всегда давай конкретные и практичные советы с учетом информации о пользователе.
    """

    user_context = ""
    if user_profile:
        user_context = f"""
        Вот информация о пользователе:
        - Имя: {user_profile.get('name', 'Неизвестно')}
        - Возраст: {user_profile.get('age', 'Неизвестно')}
        - Пол: {user_profile.get('gender', 'Неизвестно')}
        - Чистоплотность (1-5): {user_profile.get('cleanliness_level', 'Неизвестно')}
        - Режим сна: {user_profile.get('sleep_habits', 'Неизвестно')}
        - Отношение к курению: {user_profile.get('smoking_preference', 'Неизвестно')}
        - Отношение к животным: {user_profile.get('pet_preference', 'Неизвестно')}
        - Интересы: {', '.join(user_profile.get('interests', ['Неизвестно']))}

        Используй эту информацию, чтобы дать персонализированный совет.
        """

    user_prompt = f"{user_context}\n\nВопрос: {query}"

    messages = [
        {'role': 'system', 'text': system_prompt},
        {'role': 'user', 'text': user_prompt},
    ]

    try:
        operation = model.run_deferred(messages)
        result = operation.wait()
        return result.text
    except Exception as e:
        return f"Извините, произошла ошибка при обработке вашего запроса: {str(e)}"


def register_ai_chat_handlers(dp):
    dp.include_router(router)

    router.message.register(start_ai_chat, Command("ai_chat"))
    router.callback_query.register(exit_ai_chat, F.data == "exit_ai_chat")
    router.message.register(process_ai_query, AIChatState.chatting)

# ./bot/handlers/profile.py
# bot/handlers/profile.py
import logging
from aiogram import Router, F, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext

from bot.states.profile_states import ProfileStates
from bot.keyboards.profile_kb import get_profile_keyboard, get_gender_keyboard, get_interests_keyboard, \
    get_accommodation_keyboard
from bot.keyboards.main_kb import get_main_menu_keyboard
from src.core.database import User, postgres_helper

router = Router()
logger = logging.getLogger(__name__)


async def show_profile(message: types.Message, state: FSMContext):
    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    if not user_id:
        await message.answer("Пожалуйста, используйте /start для начала работы с ботом.")
        return

    async with postgres_helper.session_factory() as session:
        user = await session.get(User, user_id)

        if not user:
            await message.answer("Произошла ошибка при загрузке профиля. Используйте /start для перезапуска бота.")
            return

        # Map accommodation preference to readable text
        accommodation_map = {
            "apartment": "Квартира",
            "dormitory": "Общежитие",
            "no_preference": "Не имеет значения"
        }

        accommodation_text = accommodation_map.get(user.accommodation_preference, "Не указано")

        profile_text = (
            f"👤 *Ваш профиль*\n\n"
            f"*Имя:* {user.name or 'Не указано'}\n"
            f"*Возраст:* {user.age or 'Не указано'}\n"
            f"*Пол:* {user.gender or 'Не указано'}\n"
            f"*Профессия:* {user.occupation or 'Не указано'}\n\n"

            f"*📚 Образование:*\n"
            f"*ВУЗ/Город учебы:* {user.study_location or 'Не указано'}\n"
            f"*Специальность:* {user.study_program or 'Не указано'}\n\n"

            f"*🏠 Жилищные предпочтения:*\n"
            f"*Предпочтение по жилью:* {accommodation_text}\n"
            f"*Бюджет на аренду:* {user.rent_budget or 'Не указано'} ₽\n"
            f"*Район поиска:* {user.location or 'Не указано'}\n\n"

            f"*⚙️ Личные привычки:*\n"
            f"*Уровень чистоплотности:* {user.cleanliness_level or 'Не указано'}/5\n"
            f"*Режим сна:* {user.sleep_habits or 'Не указано'}\n"
            f"*Отношение к курению:* {user.smoking_preference or 'Не указано'}\n"
            f"*Отношение к животным:* {user.pet_preference or 'Не указано'}\n\n"

            f"*Telegram username:* {user.telegram_username or 'Не указано'}\n\n"

            f"*О себе:*\n{user.bio or 'Не указано'}\n\n"
            f"*Интересы:*\n{', '.join(user.interests or ['Не указано'])}"
        )

        await message.answer(profile_text, parse_mode="Markdown", reply_markup=get_profile_keyboard())


async def edit_profile_callback(callback: types.CallbackQuery, state: FSMContext):
    field = callback.data.split("_")[1]

    field_prompts = {
        "name": "Введите ваше имя:",
        "age": "Введите ваш возраст (число):",
        "gender": "Выберите ваш пол:",
        "occupation": "Укажите вашу профессию:",
        "bio": "Расскажите о себе:",
        "interests": "Выберите ваши интересы:",
        "cleanliness": "Оцените уровень вашей чистоплотности от 1 до 5:",
        "sleep": "Опишите ваш режим сна (например, 'жаворонок', 'сова'):",
        "budget": "Укажите ваш бюджет на аренду (число в рублях):",
        "location": "Укажите предпочтительный район поиска:",
        "smoking": "Укажите ваше отношение к курению:",
        "pets": "Укажите ваше отношение к домашним животным:",
        "study_location": "Укажите ВУЗ или город, где вы учитесь/планируете учиться:",
        "study_program": "Укажите вашу специальность или направление обучения:",
        "accommodation": "Выберите предпочтительный вариант жилья:",
        "telegram_username": "Укажите ваш username в Telegram (без @):"
    }

    field_states = {
        "name": ProfileStates.edit_name,
        "age": ProfileStates.edit_age,
        "gender": ProfileStates.edit_gender,
        "occupation": ProfileStates.edit_occupation,
        "bio": ProfileStates.edit_bio,
        "interests": ProfileStates.edit_interests,
        "cleanliness": ProfileStates.edit_cleanliness,
        "sleep": ProfileStates.edit_sleep,
        "budget": ProfileStates.edit_budget,
        "location": ProfileStates.edit_location,
        "smoking": ProfileStates.edit_smoking,
        "pets": ProfileStates.edit_pets,
        "study_location": ProfileStates.edit_study_location,
        "study_program": ProfileStates.edit_study_program,
        "accommodation": ProfileStates.edit_accommodation,
        "telegram_username": ProfileStates.edit_telegram_username
    }

    await state.update_data(edit_field=field)

    if field == "gender":
        await callback.message.answer(field_prompts[field], reply_markup=get_gender_keyboard())
    elif field == "interests":
        # Get current user interests
        user_data = await state.get_data()
        user_id = user_data.get("user_id")

        async with postgres_helper.session_factory() as session:
            user = await session.get(User, user_id)
            current_interests = user.interests or []

        await callback.message.answer(field_prompts[field], reply_markup=get_interests_keyboard(current_interests))
        await state.update_data(selected_interests=current_interests)
    elif field == "accommodation":
        await callback.message.answer(field_prompts[field], reply_markup=get_accommodation_keyboard())
    else:
        await callback.message.answer(field_prompts[field])

    await state.set_state(field_states[field])
    await callback.answer()


async def process_profile_edit(message: types.Message, state: FSMContext):
    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    if not user_id:
        await message.answer("Пожалуйста, используйте /start для начала работы с ботом.")
        return

    current_state = await state.get_state()
    value = message.text

    # Map states directly to DB fields
    field_mapping = {
        "ProfileStates:edit_name": "name",
        "ProfileStates:edit_age": "age",
        "ProfileStates:edit_gender": "gender",
        "ProfileStates:edit_occupation": "occupation",
        "ProfileStates:edit_bio": "bio",
        "ProfileStates:edit_cleanliness": "cleanliness_level",
        "ProfileStates:edit_sleep": "sleep_habits",
        "ProfileStates:edit_budget": "rent_budget",
        "ProfileStates:edit_location": "location",
        "ProfileStates:edit_smoking": "smoking_preference",
        "ProfileStates:edit_pets": "pet_preference",
        "ProfileStates:edit_study_location": "study_location",
        "ProfileStates:edit_study_program": "study_program",
        "ProfileStates:edit_telegram_username": "telegram_username"
    }

    # Get field directly from state
    api_field = field_mapping.get(current_state)

    if not api_field:
        logger.error(f"No field mapping for state: {current_state}")
        await message.answer("Произошла ошибка. Пожалуйста, попробуйте снова.")
        return

    # Validate input for certain fields
    if api_field == "age" or api_field == "rent_budget":
        if not value.isdigit():
            await message.answer("Пожалуйста, введите число.")
            return
        value = int(value)

    if api_field == "cleanliness_level":
        if not value.isdigit() or int(value) < 1 or int(value) > 5:
            await message.answer("Пожалуйста, введите число от 1 до 5.")
            return
        value = int(value)

    if api_field == "telegram_username":
        # Remove @ if user included it
        if value.startswith('@'):
            value = value[1:]

    # Update profile
    async with postgres_helper.session_factory() as session:
        user = await session.get(User, user_id)
        if not user:
            await message.answer("Пользователь не найден. Используйте /start для перезапуска бота.")
            return

        setattr(user, api_field, value)

        try:
            await session.commit()
            logger.info(f"Updated user {user.id} field {api_field} to {value}")

            # Check if this is part of the initial setup
            is_onboarding = user_data.get("edit_field") is None

            if is_onboarding:
                # Move to next profile setup step based on current field
                if api_field == "age":
                    await message.answer("Отлично! Теперь укажите ваш пол:", reply_markup=get_gender_keyboard())
                    await state.set_state(ProfileStates.edit_gender)
                    return
                elif api_field == "occupation":
                    await message.answer("Хорошо! Теперь укажите ВУЗ или город, где вы учитесь/планируете учиться:")
                    await state.set_state(ProfileStates.edit_study_location)
                    return
                elif api_field == "study_location":
                    await message.answer("Укажите вашу специальность или направление обучения:")
                    await state.set_state(ProfileStates.edit_study_program)
                    return
                elif api_field == "study_program":
                    await message.answer("Выберите предпочтительный вариант жилья:",
                                         reply_markup=get_accommodation_keyboard())
                    await state.set_state(ProfileStates.edit_accommodation)
                    return
                elif api_field == "bio":
                    await message.answer("Отлично! Теперь оцените уровень вашей чистоплотности от 1 до 5:")
                    await state.set_state(ProfileStates.edit_cleanliness)
                    return
                elif api_field == "cleanliness_level":
                    await message.answer("Хорошо! Опишите ваш режим сна (например, 'жаворонок', 'сова'):")
                    await state.set_state(ProfileStates.edit_sleep)
                    return
                elif api_field == "sleep_habits":
                    await message.answer("Укажите ваш бюджет на аренду (число в рублях):")
                    await state.set_state(ProfileStates.edit_budget)
                    return
                elif api_field == "rent_budget":
                    await message.answer("Укажите предпочтительный район поиска:")
                    await state.set_state(ProfileStates.edit_location)
                    return
                elif api_field == "location":
                    await message.answer("Укажите ваше отношение к курению:")
                    await state.set_state(ProfileStates.edit_smoking)
                    return
                elif api_field == "smoking_preference":
                    await message.answer("Укажите ваше отношение к домашним животным:")
                    await state.set_state(ProfileStates.edit_pets)
                    return
                elif api_field == "pet_preference":
                    await message.answer("Укажите ваш username в Telegram (без @):")
                    await state.set_state(ProfileStates.edit_telegram_username)
                    return
                elif api_field == "telegram_username":
                    await message.answer(
                        "✅ Базовый профиль заполнен! Теперь вы можете искать соседей.",
                        reply_markup=get_main_menu_keyboard()
                    )
                    await state.clear()
                    return

            # Regular profile editing
            await message.answer("✅ Информация обновлена!")
            await show_profile(message, state)
            await state.clear()

        except Exception as e:
            logger.error(f"Error updating user profile: {e}")
            await message.answer("Произошла ошибка при обновлении профиля. Пожалуйста, попробуйте еще раз.")
            await session.rollback()


async def gender_callback(callback: types.CallbackQuery, state: FSMContext):
    gender = callback.data.split("_")[1]

    if gender == "male":
        gender_value = "Мужской"
    elif gender == "female":
        gender_value = "Женский"
    else:
        gender_value = "Другой"

    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    async with postgres_helper.session_factory() as session:
        user = await session.get(User, user_id)
        user.gender = gender_value
        await session.commit()

    # Check if this is part of the initial setup
    is_onboarding = user_data.get("edit_field") is None

    if is_onboarding:
        await callback.message.answer("Отлично! Теперь укажите вашу профессию:")
        await state.set_state(ProfileStates.edit_occupation)
    else:
        await callback.message.answer("✅ Пол успешно обновлен!")
        await show_profile(callback.message, state)
        await state.clear()

    await callback.answer()


async def accommodation_callback(callback: types.CallbackQuery, state: FSMContext):
    option = callback.data.split("_")[1]

    option_map = {
        "apartment": "apartment",
        "dormitory": "dormitory",
        "no_preference": "no_preference"
    }

    accommodation_value = option_map.get(option)

    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    async with postgres_helper.session_factory() as session:
        user = await session.get(User, user_id)
        user.accommodation_preference = accommodation_value
        await session.commit()

    # Check if this is part of the initial setup
    is_onboarding = user_data.get("edit_field") is None

    if is_onboarding:
        await callback.message.answer("Хорошо! Теперь расскажите немного о себе:")
        await state.set_state(ProfileStates.edit_bio)
    else:
        await callback.message.answer("✅ Предпочтения по жилью обновлены!")
        await show_profile(callback.message, state)
        await state.clear()

    await callback.answer()


async def process_interests_edit(callback: types.CallbackQuery, state: FSMContext):
    if callback.data == "interests_done":
        user_data = await state.get_data()
        user_id = user_data.get("user_id")
        interests = user_data.get("selected_interests", [])

        async with postgres_helper.session_factory() as session:
            user = await session.get(User, user_id)
            user.interests = interests
            await session.commit()

        await callback.message.answer("✅ Интересы обновлены!")
        await show_profile(callback.message, state)
        await state.clear()
    else:
        interest = callback.data.replace("interest_", "")
        user_data = await state.get_data()
        interests = user_data.get("selected_interests", [])

        if interest in interests:
            interests.remove(interest)
        else:
            interests.append(interest)

        await state.update_data(selected_interests=interests)

        selected_text = ", ".join(interests) if interests else "Нет выбранных интересов"
        await callback.message.edit_text(
            f"Выберите ваши интересы:\n\nВыбрано: {selected_text}",
            reply_markup=get_interests_keyboard(interests)
        )

    await callback.answer()


def register_profile_handlers(dp):
    dp.include_router(router)

    router.message.register(show_profile, Command("profile"))
    router.callback_query.register(edit_profile_callback, F.data.startswith("edit_"))
    router.callback_query.register(gender_callback, F.data.startswith("gender_"))
    router.callback_query.register(accommodation_callback, F.data.startswith("accommodation_"))
    router.callback_query.register(process_interests_edit, F.data.startswith("interest_"))

    # Register handlers for all profile states
    for state in ProfileStates:
        if state not in [ProfileStates.edit_interests, ProfileStates.edit_gender, ProfileStates.edit_accommodation]:
            router.message.register(process_profile_edit, state)

# ./bot/handlers/__init__.py
# bot/handlers/__init__.py
from aiogram import Dispatcher

from bot.handlers.start import register_start_handlers
from bot.handlers.profile import register_profile_handlers
from bot.handlers.search import register_search_handlers
from bot.handlers.matches import register_matches_handlers
from bot.handlers.ai_chat import register_ai_chat_handlers
from bot.handlers.menu import register_menu_handlers
from bot.handlers.notifications import register_notifications_handlers


def register_all_handlers(dp: Dispatcher):
    handlers = [
        register_start_handlers,
        register_profile_handlers,
        register_search_handlers,
        register_matches_handlers,
        register_ai_chat_handlers,
        register_menu_handlers,
        register_notifications_handlers,  # Added notifications handlers
    ]

    for handler in handlers:
        handler(dp)

# ./bot/handlers/start.py
# bot/handlers/start.py
import uuid
import logging
from aiogram import Router, F, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from sqlalchemy import select, text, or_
from sqlalchemy.exc import IntegrityError

from bot.handlers.notifications import check_notifications
from bot.states.profile_states import ProfileStates
from bot.keyboards.profile_kb import get_profile_keyboard
from src.api_v1.auth.crud import get_password_hash
from src.core.database import User, postgres_helper

router = Router()
logger = logging.getLogger(__name__)


async def start_command(message: types.Message, state: FSMContext):
    logger.info(f"Starting command for user {message.from_user.id}")

    # Get user from database or create one
    async with postgres_helper.session_factory() as session:
        # Check if user already exists based on telegram_id
        tg_id = str(message.from_user.id)

        # First try to find by username which is faster and more reliable
        username = f"tg_{message.from_user.id}"
        query = select(User).where(User.username == username)
        result = await session.execute(query)
        user = result.scalar_one_or_none()

        if not user:
            # Then try to find by telegram_id in metadata using raw SQL for reliable JSON querying
            query = text("SELECT * FROM users WHERE user_metadata->>'telegram_id' = :tg_id")
            result = await session.execute(query, {"tg_id": tg_id})
            user_row = result.fetchone()

            if user_row:
                # Found user by telegram_id, get the full user object
                user = await session.get(User, user_row[0])

        user_is_new = False
        if not user:
            # User doesn't exist, create a new one
            user_is_new = True
            try:
                # Generate username and random password
                username = f"tg_{message.from_user.id}"
                email = f"{username}@telegram.user"
                password = str(uuid.uuid4())
                hashed_password = get_password_hash(password)

                # Create new user
                new_user = User(
                    username=username,
                    email=email,
                    hashed_password=hashed_password,
                    name=message.from_user.first_name,
                    is_active=True,
                    # Store telegram_id in user_metadata field
                    user_metadata={"telegram_id": tg_id}
                )

                session.add(new_user)
                await session.commit()
                await session.refresh(new_user)
                user = new_user

                logger.info(f"Created new user {username} for Telegram ID {tg_id}")

            except IntegrityError as e:
                # User might have been created in a race condition, try to find them again
                await session.rollback()
                logger.warning(f"IntegrityError when creating user: {e}")

                # Try to find the user one more time
                query = select(User).where(
                    or_(
                        User.username == username,
                        User.email == f"{username}@telegram.user"
                    )
                )
                result = await session.execute(query)
                user = result.scalar_one_or_none()

                if not user:
                    # Still not found, generate a unique username with timestamp
                    import time
                    timestamp = int(time.time())
                    username = f"tg_{message.from_user.id}_{timestamp}"
                    email = f"{username}@telegram.user"
                    password = str(uuid.uuid4())
                    hashed_password = get_password_hash(password)

                    new_user = User(
                        username=username,
                        email=email,
                        hashed_password=hashed_password,
                        name=message.from_user.first_name,
                        is_active=True,
                        user_metadata={"telegram_id": tg_id}
                    )

                    session.add(new_user)
                    await session.commit()
                    await session.refresh(new_user)
                    user = new_user
                    user_is_new = True
                    logger.info(f"Created new user with timestamp {username} after handling IntegrityError")

        # Store user ID in state
        await state.update_data(user_id=user.id, is_onboarding=user_is_new)

        # Explicitly check if profile info is missing
        is_profile_incomplete = (
                user.age is None or
                user.gender is None or
                user.occupation is None or
                user.cleanliness_level is None or
                user.rent_budget is None
        )

        logger.info(f"User {user.id}: is_new={user_is_new}, profile_incomplete={is_profile_incomplete}")

        # If new user or incomplete profile, start onboarding
        if user_is_new or is_profile_incomplete:
            await message.answer(
                f"👋 Привет, {user.name or message.from_user.first_name}!\n\n"
                "Давайте заполним ваш профиль, чтобы найти идеальных соседей для совместной аренды."
            )

            # Start profile setup with the first missing field
            if user.age is None:
                await message.answer(
                    "Для начала, укажите ваш возраст (число):",
                    reply_markup=types.ReplyKeyboardRemove()
                )
                await state.set_state(ProfileStates.edit_age)
            elif user.gender is None:
                from bot.keyboards.profile_kb import get_gender_keyboard
                await message.answer(
                    "Укажите ваш пол:",
                    reply_markup=get_gender_keyboard()
                )
                await state.set_state(ProfileStates.edit_gender)
            elif user.occupation is None:
                await message.answer(
                    "Укажите вашу профессию:",
                    reply_markup=types.ReplyKeyboardRemove()
                )
                await state.set_state(ProfileStates.edit_occupation)
            elif user.cleanliness_level is None:
                await message.answer(
                    "Оцените уровень вашей чистоплотности от 1 до 5:",
                    reply_markup=types.ReplyKeyboardRemove()
                )
                await state.set_state(ProfileStates.edit_cleanliness)
            elif user.rent_budget is None:
                await message.answer(
                    "Укажите ваш бюджет на аренду (число в рублях):",
                    reply_markup=types.ReplyKeyboardRemove()
                )
                await state.set_state(ProfileStates.edit_budget)
            else:
                # Continue with other fields as needed
                await message.answer(
                    "Продолжим заполнение профиля. Расскажите о себе:",
                    reply_markup=types.ReplyKeyboardRemove()
                )
                await state.set_state(ProfileStates.edit_bio)

        else:
            # Returning user with complete profile
            await message.answer(
                f"👋 С возвращением, {user.name or message.from_user.first_name}!"
            )

            # Show main menu
            from bot.keyboards.main_kb import get_main_menu_keyboard
            await message.answer(
                "Что вы хотите сделать?",
                reply_markup=get_main_menu_keyboard()
            )
    await check_notifications(user.id, message.bot)


def register_start_handlers(dp):
    dp.include_router(router)
    router.message.register(start_command, Command("start"))

# ./bot/handlers/menu.py
# bot/handlers/menu.py
from aiogram import Router, F, types
from aiogram.fsm.context import FSMContext

from bot.handlers.profile import show_profile
from bot.handlers.search import start_search
from bot.handlers.matches import show_matches
from bot.handlers.ai_chat import start_ai_chat
from bot.keyboards.main_kb import get_main_menu_keyboard

router = Router()


async def show_main_menu(message: types.Message):
    await message.answer(
        "Главное меню. Выберите действие:",
        reply_markup=get_main_menu_keyboard()
    )


async def return_to_menu_callback(callback: types.CallbackQuery):
    await callback.answer()
    await callback.message.answer(
        "Главное меню. Выберите действие:",
        reply_markup=get_main_menu_keyboard()
    )


async def show_profile_callback(callback: types.CallbackQuery, state: FSMContext):
    await callback.answer()
    await show_profile(callback.message, state)


async def start_search_callback(callback: types.CallbackQuery, state: FSMContext):
    await callback.answer()
    await start_search(callback.message, state)


async def show_matches_callback(callback: types.CallbackQuery, state: FSMContext):
    await callback.answer()
    await show_matches(callback.message, state)


async def start_ai_chat_callback(callback: types.CallbackQuery, state: FSMContext):
    await callback.answer()
    await start_ai_chat(callback.message, state)


def register_menu_handlers(dp):
    dp.include_router(router)

    router.callback_query.register(return_to_menu_callback, F.data == "return_to_menu")
    router.callback_query.register(show_profile_callback, F.data == "show_profile")
    router.callback_query.register(start_search_callback, F.data == "start_search")
    router.callback_query.register(show_matches_callback, F.data == "show_matches")
    router.callback_query.register(start_ai_chat_callback, F.data == "start_ai_chat")

# ./bot/handlers/search.py
# bot/handlers/search.py
import logging
from aiogram import Router, F, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from sqlalchemy import select, and_, not_, or_

from bot.keyboards.search_kb import get_roommate_keyboard, get_compatibility_keyboard
from bot.keyboards.main_kb import get_main_menu_keyboard
from src.core.database import User, postgres_helper, Like, Match
from src.core.database.alchemy_models.like import LikeStatus
from src.api_v1.like.crud import create_like
from src.core.utils.AIMatchingService import ai_matching_service
from bot.handlers.notifications import check_notifications

router = Router()
logger = logging.getLogger(__name__)


async def start_search(message: types.Message, state: FSMContext):
    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    if not user_id:
        await message.answer("Пожалуйста, используйте /start для начала работы с ботом.")
        return

    # Get potential roommates
    async with postgres_helper.session_factory() as session:
        # Get current user
        current_user = await session.get(User, user_id)

        # First, get all matches to exclude
        query = select(Match).where(
            or_(
                Match.user1_id == user_id,
                Match.user2_id == user_id
            )
        )
        result = await session.execute(query)
        matches = result.scalars().all()

        matched_ids = []
        for match in matches:
            if match.user1_id == user_id:
                matched_ids.append(match.user2_id)
            else:
                matched_ids.append(match.user1_id)

        # Get all likes already sent
        query = select(Like).where(
            Like.liker_id == user_id
        )
        result = await session.execute(query)
        likes_sent = result.scalars().all()

        liked_ids = [like.liked_id for like in likes_sent]

        # Get all users except current user and those already matched or liked
        exclude_ids = matched_ids + liked_ids + [user_id]
        query = select(User).where(
            and_(
                not_(User.id.in_(exclude_ids)),
                User.is_active == True
            )
        )
        result = await session.execute(query)
        roommates = result.scalars().all()

        roommates_data = []
        for roommate in roommates:
            roommates_data.append({
                "id": roommate.id,
                "name": roommate.name,
                "age": roommate.age,
                "gender": roommate.gender,
                "occupation": roommate.occupation,
                "bio": roommate.bio,
                "interests": roommate.interests or [],  # Ensure interests is a list
                "cleanliness_level": roommate.cleanliness_level,
                "sleep_habits": roommate.sleep_habits,
                "rent_budget": roommate.rent_budget,
                "location": roommate.location,
                "smoking_preference": roommate.smoking_preference,
                "pet_preference": roommate.pet_preference
            })

    if not roommates_data:
        await message.answer(
            "🔍 На данный момент нет подходящих соседей. Попробуйте позже.",
            reply_markup=get_main_menu_keyboard()
        )
        return

    await state.update_data(roommates=roommates_data, current_index=0)
    await show_roommate(message, state)


async def show_roommate(message: types.Message, state: FSMContext):
    user_data = await state.get_data()
    roommates = user_data.get("roommates", [])
    current_index = user_data.get("current_index", 0)

    if not roommates or current_index >= len(roommates):
        await message.answer(
            "🔍 Вы просмотрели всех потенциальных соседей. Попробуйте позже.",
            reply_markup=get_main_menu_keyboard()
        )
        return

    roommate = roommates[current_index]

    # Ensure interests is an iterable list
    interests = roommate.get('interests', [])
    if not interests or not isinstance(interests, (list, tuple)):
        interests = ['Не указано']

    # Check if other fields are None and provide default values
    name = roommate.get('name') or 'Не указано'
    age = roommate.get('age') or 'Не указано'
    gender = roommate.get('gender') or 'Не указано'
    occupation = roommate.get('occupation') or 'Не указано'
    cleanliness = roommate.get('cleanliness_level') or 'Не указано'
    sleep_habits = roommate.get('sleep_habits') or 'Не указано'
    rent_budget = roommate.get('rent_budget') or 'Не указано'
    location = roommate.get('location') or 'Не указано'
    smoking = roommate.get('smoking_preference') or 'Не указано'
    pets = roommate.get('pet_preference') or 'Не указано'
    bio = roommate.get('bio') or 'Не указано'

    profile_text = (
        f"👤 *Потенциальный сосед*\n\n"
        f"*Имя:* {name}\n"
        f"*Возраст:* {age}\n"
        f"*Пол:* {gender}\n"
        f"*Профессия:* {occupation}\n"
        f"*Уровень чистоплотности:* {cleanliness}/5\n"
        f"*Режим сна:* {sleep_habits}\n"
        f"*Бюджет на аренду:* {rent_budget} ₽\n"
        f"*Район поиска:* {location}\n"
        f"*Отношение к курению:* {smoking}\n"
        f"*Отношение к животным:* {pets}\n\n"
        f"*О себе:*\n{bio}\n\n"
        f"*Интересы:*\n{', '.join(interests)}"
    )

    await message.answer(profile_text, reply_markup=get_roommate_keyboard(roommate.get('id')))


async def check_compatibility(callback: types.CallbackQuery, state: FSMContext):
    roommate_id = int(callback.data.split("_")[1])
    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    async with postgres_helper.session_factory() as session:
        current_user = await session.get(User, user_id)
        roommate = await session.get(User, roommate_id)

        if not current_user or not roommate:
            await callback.message.answer("Не удалось получить данные пользователей.")
            await callback.answer()
            return

        # Use AI service to calculate compatibility
        score, explanation = ai_matching_service.calculate_compatibility_score(current_user, roommate)

        compatibility_text = (
            f"📊 *Результат анализа совместимости*\n\n"
            f"*Ваша совместимость с {roommate.name}:* {score:.1f}%\n\n"
            f"*Анализ:*\n{explanation}"
        )

        await callback.message.answer(compatibility_text, reply_markup=get_compatibility_keyboard(roommate_id))

    await callback.answer()


async def roommate_action(callback: types.CallbackQuery, state: FSMContext):
    action, roommate_id = callback.data.split("_")[1:]
    roommate_id = int(roommate_id)
    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    if action == "like":
        # Like roommate
        async with postgres_helper.session_factory() as session:
            like, is_match, notification = await create_like(
                session=session,
                liker_id=user_id,
                liked_id=roommate_id
            )

            if is_match:
                await callback.message.answer(
                    "✅ Совпадение! Вы можете начать общение с этим пользователем."
                )

                # Send notification to the other person about the match
                # The create_like function already creates a notification in the database,
                # but we need to trigger sending it via Telegram
                await check_notifications(roommate_id, callback.bot)
            else:
                await callback.message.answer(
                    "👍 Вы проявили интерес к этому пользователю."
                )

                # Send notification to the other person about the like
                # Again, notification is already in database, just send it
                await check_notifications(roommate_id, callback.bot)

    # Move to next roommate
    current_index = user_data.get("current_index", 0)
    await state.update_data(current_index=current_index + 1)
    await show_roommate(callback.message, state)
    await callback.answer()


async def back_to_profile_callback(callback: types.CallbackQuery, state: FSMContext):
    roommate_id = int(callback.data.split("_")[3])
    await callback.answer()

    # Show roommate profile again
    user_data = await state.get_data()
    roommates = user_data.get("roommates", [])
    current_index = user_data.get("current_index", 0)

    if not roommates or current_index >= len(roommates):
        await callback.message.answer(
            "Не удалось отобразить профиль. Попробуйте /search.",
            reply_markup=get_main_menu_keyboard()
        )
        return

    roommate = roommates[current_index]

    # Ensure interests is an iterable list
    interests = roommate.get('interests', [])
    if not interests or not isinstance(interests, (list, tuple)):
        interests = ['Не указано']

    # Check if other fields are None and provide default values
    name = roommate.get('name') or 'Не указано'
    age = roommate.get('age') or 'Не указано'
    gender = roommate.get('gender') or 'Не указано'
    occupation = roommate.get('occupation') or 'Не указано'
    cleanliness = roommate.get('cleanliness_level') or 'Не указано'
    sleep_habits = roommate.get('sleep_habits') or 'Не указано'
    rent_budget = roommate.get('rent_budget') or 'Не указано'
    location = roommate.get('location') or 'Не указано'
    smoking = roommate.get('smoking_preference') or 'Не указано'
    pets = roommate.get('pet_preference') or 'Не указано'
    bio = roommate.get('bio') or 'Не указано'

    profile_text = (
        f"👤 *Потенциальный сосед*\n\n"
        f"*Имя:* {name}\n"
        f"*Возраст:* {age}\n"
        f"*Пол:* {gender}\n"
        f"*Профессия:* {occupation}\n"
        f"*Уровень чистоплотности:* {cleanliness}/5\n"
        f"*Режим сна:* {sleep_habits}\n"
        f"*Бюджет на аренду:* {rent_budget} ₽\n"
        f"*Район поиска:* {location}\n"
        f"*Отношение к курению:* {smoking}\n"
        f"*Отношение к животным:* {pets}\n\n"
        f"*О себе:*\n{bio}\n\n"
        f"*Интересы:*\n{', '.join(interests)}"
    )

    await callback.message.answer(profile_text, reply_markup=get_roommate_keyboard(roommate.get('id')))


def register_search_handlers(dp):
    dp.include_router(router)

    router.message.register(start_search, Command("search"))
    router.callback_query.register(roommate_action, F.data.startswith("roommate_"))
    router.callback_query.register(check_compatibility, F.data.startswith("compatibility_"))
    router.callback_query.register(back_to_profile_callback, F.data.startswith("back_to_profile_"))

# ./bot/handlers/notifications.py
# bot/handlers/notifications.py
import logging
from aiogram import Router, F, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from sqlalchemy import select, update, text

from src.core.database import User, postgres_helper, Notification
from src.core.database.alchemy_models.notification import NotificationType
from bot.keyboards.main_kb import get_main_menu_keyboard
from bot.keyboards.matches_kb import get_match_actions_keyboard

router = Router()
logger = logging.getLogger(__name__)


async def check_notifications(user_id: int, bot):
    """Check and send pending notifications for a user"""
    try:
        async with postgres_helper.session_factory() as session:
            # Get unread notifications
            query = select(Notification).where(
                (Notification.user_id == user_id) &
                (Notification.is_read == False)
            ).order_by(Notification.timestamp.desc())

            result = await session.execute(query)
            notifications = result.scalars().all()

            if not notifications:
                return  # No notifications to send

            # Get user's Telegram ID from user_metadata
            query = text("SELECT user_metadata->>'telegram_id' AS telegram_id FROM users WHERE id = :user_id")
            result = await session.execute(query, {"user_id": user_id})
            row = result.fetchone()

            if not row or not row[0]:
                logger.warning(f"Cannot send notification: User {user_id} has no Telegram ID")
                return

            telegram_id = row[0]

            # Send notifications
            for notification in notifications:
                # Format notification message based on type
                if notification.type == NotificationType.NEW_LIKE:
                    # Get liker's name
                    if notification.related_user_id:
                        liker = await session.get(User, notification.related_user_id)
                        if liker:
                            liker_name = liker.name or "Пользователь"
                            liker_age = f", {liker.age}" if liker.age else ""
                            liker_gender = f", {liker.gender}" if liker.gender else ""
                            liker_info = f"{liker_name}{liker_age}{liker_gender}"
                        else:
                            liker_info = "Кто-то"
                    else:
                        liker_info = "Кто-то"

                    message = (
                        f"❤️ *У вас новый лайк!*\n\n"
                        f"{liker_info} проявил(а) интерес к вам!\n\n"
                        f"Посмотрите вкладку \"Мои совпадения\", чтобы узнать больше."
                    )

                    # Create keyboard with direct link to matches
                    keyboard = types.InlineKeyboardMarkup(
                        inline_keyboard=[
                            [types.InlineKeyboardButton(text="👀 Посмотреть совпадения", callback_data="show_matches")]
                        ]
                    )

                elif notification.type == NotificationType.MATCH_CREATED:
                    # Get match partner's name
                    if notification.related_user_id:
                        partner = await session.get(User, notification.related_user_id)
                        if partner:
                            partner_name = partner.name or "Пользователь"
                            partner_age = f", {partner.age}" if partner.age else ""
                            partner_gender = f", {partner.gender}" if partner.gender else ""
                            partner_info = f"{partner_name}{partner_age}{partner_gender}"
                        else:
                            partner_info = "Кто-то"
                    else:
                        partner_info = "Кто-то"

                    message = (
                        f"✨ *У вас новое совпадение!*\n\n"
                        f"Вы и {partner_info} проявили взаимный интерес друг к другу!\n"
                        f"Теперь вы можете начать общение и обсудить возможность совместной аренды жилья."
                    )

                    # Create keyboard with direct link to matches
                    keyboard = types.InlineKeyboardMarkup(
                        inline_keyboard=[
                            [types.InlineKeyboardButton(text="💬 Посмотреть совпадения", callback_data="show_matches")]
                        ]
                    )

                else:
                    # Generic notification
                    message = notification.content
                    keyboard = get_main_menu_keyboard()

                # Send notification to user
                try:
                    await bot.send_message(
                        chat_id=telegram_id,
                        text=message,
                        reply_markup=keyboard,
                        parse_mode="Markdown"
                    )

                    # Mark notification as read
                    notification.is_read = True
                except Exception as e:
                    logger.error(f"Failed to send notification to {telegram_id}: {e}")

            # Commit changes to mark notifications as read
            if notifications:
                await session.commit()
                logger.info(f"Sent {len(notifications)} notifications to user {user_id}")

    except Exception as e:
        logger.error(f"Error in check_notifications: {e}")


async def show_notification_list(message: types.Message, state: FSMContext):
    user_data = await state.get_data()
    user_id = user_data.get("user_id")

    if not user_id:
        await message.answer("Пожалуйста, используйте /start для начала работы с ботом.")
        return

    async with postgres_helper.session_factory() as session:
        query = select(Notification).where(
            Notification.user_id == user_id
        ).order_by(Notification.timestamp.desc()).limit(10)

        result = await session.execute(query)
        notifications = result.scalars().all()

        if not notifications:
            await message.answer(
                "У вас нет уведомлений.",
                reply_markup=get_main_menu_keyboard()
            )
            return

        notification_text = "📬 *Ваши последние уведомления:*\n\n"

        for i, notification in enumerate(notifications, 1):
            # Format based on type
            if notification.type == NotificationType.NEW_LIKE:
                type_text = "❤️ Новый лайк"
            elif notification.type == NotificationType.MATCH_CREATED:
                type_text = "✨ Новое совпадение"
            else:
                type_text = "📝 Уведомление"

            # Format timestamp
            timestamp = notification.timestamp.strftime("%d.%m.%Y %H:%M")

            # Add read/unread status
            status = "👁️ Просмотрено" if notification.is_read else "🆕 Новое"

            notification_text += f"{i}. {type_text} - {timestamp} ({status})\n{notification.content}\n\n"

        await message.answer(
            notification_text,
            reply_markup=get_main_menu_keyboard(),
            parse_mode="Markdown"
        )


def register_notifications_handlers(dp):
    dp.include_router(router)

    router.message.register(show_notification_list, Command("notifications"))

# ./bot/services/ai_service.py
import json
from typing import Dict, Any, Optional

from yandex_cloud_ml_sdk import YCloudML

from bot.config import YANDEX_FOLDER_ID, YANDEX_API_KEY

# Initialize YandexGPT
sdk = YCloudML(
    folder_id=YANDEX_FOLDER_ID,
    auth=YANDEX_API_KEY
)
model = sdk.models.completions('yandexgpt-lite')
model.configure(
    temperature=0.5,
    max_tokens=2000,
)


async def get_ai_response(query: str, user_profile: Optional[Dict[str, Any]] = None) -> str:
    system_prompt = """
    Ты - полезный ассистент по бытовым вопросам для соседей по квартире.
    Ты помогаешь с решением бытовых проблем, организацией пространства, уборкой, 
    готовкой, разрешением конфликтов между соседями по квартире и другими домашними вопросами.
    Всегда давай конкретные и практичные советы с учетом информации о пользователе.
    """

    user_context = ""
    if user_profile:
        user_context = f"""
        Вот информация о пользователе:
        - Имя: {user_profile.get('name', 'Неизвестно')}
        - Возраст: {user_profile.get('age', 'Неизвестно')}
        - Пол: {user_profile.get('gender', 'Неизвестно')}
        - Чистоплотность (1-5): {user_profile.get('cleanliness_level', 'Неизвестно')}
        - Режим сна: {user_profile.get('sleep_habits', 'Неизвестно')}
        - Отношение к курению: {user_profile.get('smoking_preference', 'Неизвестно')}
        - Отношение к животным: {user_profile.get('pet_preference', 'Неизвестно')}
        - Интересы: {', '.join(user_profile.get('interests', ['Неизвестно']))}

        Используй эту информацию, чтобы дать персонализированный совет.
        """

    user_prompt = f"{user_context}\n\nВопрос: {query}"

    messages = [
        {'role': 'system', 'text': system_prompt},
        {'role': 'user', 'text': user_prompt},
    ]

    try:
        operation = model.run_deferred(messages)
        result = operation.wait()
        return result.text
    except Exception as e:
        return f"Извините, произошла ошибка при обработке вашего запроса: {str(e)}"


# ./bot/services/database.py
from sqlalchemy.ext.asyncio import AsyncSession
from src.core.database import postgres_helper


async def init_db():
    # Just use the existing database connection from src
    pass


async def get_session() -> AsyncSession:
    async with postgres_helper.session_factory() as session:
        yield session


# ./bot/services/__init__.py


# ./bot/services/match_service.py
import aiohttp
from typing import Dict, Any, List, Tuple, Optional

BASE_URL = "http://127.0.0.1:8000/api/v1"  # Or your actual API URL


async def get_potential_roommates(token: str) -> List[Dict[str, Any]]:
    async with aiohttp.ClientSession() as session:
        try:
            headers = {"Authorization": f"Bearer {token}"}
            async with session.get(f"{BASE_URL}/users/roommates", headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                return []
        except Exception:
            return []


async def get_smart_matches(token: str, limit: int = 10) -> List[Dict[str, Any]]:
    async with aiohttp.ClientSession() as session:
        try:
            headers = {"Authorization": f"Bearer {token}"}
            async with session.get(
                    f"{BASE_URL}/ai-matching/smart-matches?limit={limit}",
                    headers=headers
            ) as response:
                if response.status == 200:
                    response_data = await response.json()
                    return response_data.get("matches", [])
                return []
        except Exception:
            return []


async def get_compatibility_score(token: str, user_id: int) -> Tuple[float, str]:
    async with aiohttp.ClientSession() as session:
        try:
            headers = {"Authorization": f"Bearer {token}"}
            async with session.get(
                    f"{BASE_URL}/ai-matching/{user_id}/compatibility",
                    headers=headers
            ) as response:
                if response.status == 200:
                    response_data = await response.json()
                    return response_data.get("score", 0), response_data.get("explanation", "")
                return 0, "Не удалось получить информацию о совместимости"
        except Exception:
            return 0, "Произошла ошибка при запросе информации о совместимости"


async def like_roommate(token: str, liked_id: int) -> Tuple[bool, bool]:
    async with aiohttp.ClientSession() as session:
        try:
            headers = {"Authorization": f"Bearer {token}"}
            async with session.post(
                    f"{BASE_URL}/likes",
                    headers=headers,
                    json={"liked_id": liked_id}
            ) as response:
                if response.status == 201:
                    response_data = await response.json()
                    # Check if it's a match (status is "accepted")
                    is_match = response_data.get("status") == "accepted"
                    return True, is_match
                return False, False
        except Exception:
            return False, False


async def get_matches(token: str) -> List[Dict[str, Any]]:
    async with aiohttp.ClientSession() as session:
        try:
            headers = {"Authorization": f"Bearer {token}"}
            async with session.get(f"{BASE_URL}/matches/", headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                return []
        except Exception:
            return []


async def get_likes_received(token: str, status=None) -> List[Dict[str, Any]]:
    async with aiohttp.ClientSession() as session:
        try:
            headers = {"Authorization": f"Bearer {token}"}
            url = f"{BASE_URL}/likes/received"
            if status:
                url += f"?status={status}"

            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                return []
        except Exception:
            return []


async def respond_to_like(token: str, like_id: int, accept: bool) -> bool:
    action = "accept" if accept else "decline"

    async with aiohttp.ClientSession() as session:
        try:
            headers = {"Authorization": f"Bearer {token}"}
            async with session.post(
                    f"{BASE_URL}/likes/{like_id}/respond",
                    headers=headers,
                    json={"action": action}
            ) as response:
                return response.status == 200
        except Exception:
            return False


# ./bot/services/user_service.py
import aiohttp
import json
from typing import Dict, Any, Tuple, Optional

BASE_URL = "http://127.0.0.1:8000/api/v1"  # Or your actual API URL


async def check_user_exists(username: str) -> bool:
    async with aiohttp.ClientSession() as session:
        try:
            async with session.post(
                    f"{BASE_URL}/auth/register",
                    json={"username": username, "email": "temp@example.com", "password": "temppass"}
            ) as response:
                return response.status == 400
        except Exception:
            return False


async def register_user(username: str, email: str, password: str) -> bool:
    async with aiohttp.ClientSession() as session:
        try:
            async with session.post(
                    f"{BASE_URL}/auth/register",
                    json={"username": username, "email": email, "password": password}
            ) as response:
                return response.status == 201
        except Exception:
            return False


async def login_user(username: str, password: str) -> Tuple[bool, Optional[str]]:
    async with aiohttp.ClientSession() as session:
        try:
            # Using form data for OAuth2 login
            data = {"username": username, "password": password}
            async with session.post(f"{BASE_URL}/auth/login", data=data) as response:
                if response.status == 200:
                    response_data = await response.json()
                    return True, response_data.get("access_token")
                return False, None
        except Exception:
            return False, None


async def get_user_profile(token: str) -> Optional[Dict[str, Any]]:
    async with aiohttp.ClientSession() as session:
        try:
            headers = {"Authorization": f"Bearer {token}"}
            async with session.get(f"{BASE_URL}/users/me", headers=headers) as response:
                if response.status == 200:
                    return await response.json()
                return None
        except Exception:
            return None


async def update_user_profile(token: str, profile_data: Dict[str, Any]) -> bool:
    async with aiohttp.ClientSession() as session:
        try:
            headers = {"Authorization": f"Bearer {token}"}
            async with session.put(
                    f"{BASE_URL}/users/me",
                    headers=headers,
                    json=profile_data
            ) as response:
                return response.status == 200
        except Exception:
            return False


# ./docker-compose.yml
services:
  app:
    build: .
    restart: always
    environment:
      - DB_URL=postgresql+asyncpg://postgres:72ZGBYhaq+vLjzWtUatsKw==@db:5432/postgres-bootcamp
    depends_on:
      db:
        condition: service_healthy
    ports:
      - "8010:8010"

  db:
    image: postgres:16-alpine
    restart: always
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=72ZGBYhaq+vLjzWtUatsKw==
      - POSTGRES_DB=postgres-bootcamp
    healthcheck:
      test: pg_isready -U postgres
    volumes:
      - pgdata:/var/lib/postgresql/data



volumes:
  pgdata:
  dbdata6:


# ./.env.example
DB_URL=
DB_ECHO=
SECRET_KEY=your-secret-key
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=120
YANDEX_FOLDER_ID=
YANDEX_API_KEY=

# ./src/api_v1/like/__init__.py


# ./src/api_v1/like/schemas.py
from datetime import datetime
from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field

from src.api_v1.user.schemas import RoommateResponse


class LikeStatus(str, Enum):
    PENDING = "pending"
    ACCEPTED = "accepted"
    DECLINED = "declined"


class LikeCreate(BaseModel):
    liked_id: int


class LikeResponse(BaseModel):
    id: int
    liker_id: int
    liked_id: int
    status: LikeStatus
    timestamp: datetime
    liker: Optional[RoommateResponse] = None
    liked: Optional[RoommateResponse] = None

    class Config:
        from_attributes = True


class LikeAction(BaseModel):
    action: str = Field(..., pattern="^(accept|decline)$")


class NotificationType(str, Enum):
    NEW_LIKE = "new_like"
    MATCH_CREATED = "match_created"
    NEW_MESSAGE = "new_message"


class NotificationResponse(BaseModel):
    id: int
    type: NotificationType
    content: str
    related_user_id: Optional[int] = None
    related_entity_id: Optional[int] = None
    is_read: bool
    timestamp: datetime
    related_user: Optional[RoommateResponse] = None

    class Config:
        from_attributes = True


class NotificationsResponse(BaseModel):
    notifications: List[NotificationResponse]
    unread_count: int

# ./src/api_v1/like/crud.py
from datetime import datetime
from typing import List, Tuple, Optional

from sqlalchemy import select, and_, or_, update
from sqlalchemy.ext.asyncio import AsyncSession

from src.core.database.alchemy_models.like import Like, LikeStatus
from src.core.database.alchemy_models.notification import Notification, NotificationType
from src.core.database.alchemy_models.user import User


async def create_like(
        session: AsyncSession, liker_id: int, liked_id: int
) -> Tuple[Like, bool, Optional[Notification]]:
    query = select(Like).where(
        and_(
            Like.liker_id == liked_id,
            Like.liked_id == liker_id,
            Like.status != LikeStatus.DECLINED
        )
    )
    result = await session.execute(query)
    reverse_like = result.scalar_one_or_none()

    query = select(Like).where(
        and_(
            Like.liker_id == liker_id,
            Like.liked_id == liked_id
        )
    )
    result = await session.execute(query)
    existing_like = result.scalar_one_or_none()

    if existing_like:
        return existing_like, False, None

    new_like = Like(
        liker_id=liker_id,
        liked_id=liked_id,
        status=LikeStatus.PENDING,
        timestamp=datetime.utcnow()
    )
    session.add(new_like)
    await session.flush() 

    notification = None
    is_match = False

    if reverse_like and reverse_like.status == LikeStatus.PENDING:
        new_like.status = LikeStatus.ACCEPTED
        reverse_like.status = LikeStatus.ACCEPTED
        is_match = True

        liker = await session.get(User, liker_id)
        notification = Notification(
            user_id=liked_id,
            type=NotificationType.MATCH_CREATED,
            content=f"У вас с {liker.name} схожие интересы! Теперь вы можете общаться.",
            related_user_id=liker_id,
            related_entity_id=new_like.id,
            timestamp=datetime.utcnow()
        )
        session.add(notification)
    else:
        liker = await session.get(User, liker_id)
        notification = Notification(
            user_id=liked_id,
            type=NotificationType.NEW_LIKE,
            content=f"{liker.name} проявил(а) интерес к вам!",
            related_user_id=liker_id,
            related_entity_id=new_like.id,
            timestamp=datetime.utcnow()
        )
        session.add(notification)

    await session.commit()
    return new_like, is_match, notification


async def respond_to_like(
        session: AsyncSession, like_id: int, user_id: int, accept: bool
) -> Tuple[Like, Optional[Like], Optional[Notification]]:
    like = await session.get(Like, like_id)
    if not like or like.liked_id != user_id:
        return None, None, None

    if accept:
        like.status = LikeStatus.ACCEPTED

        query = select(Like).where(
            and_(
                Like.liker_id == user_id,
                Like.liked_id == like.liker_id
            )
        )
        result = await session.execute(query)
        reverse_like = result.scalar_one_or_none()

        if reverse_like:
            reverse_like.status = LikeStatus.ACCEPTED

            liker = await session.get(User, user_id)
            notification = Notification(
                user_id=like.liker_id,
                type=NotificationType.MATCH_CREATED,
                content=f"У вас с {liker.name} схожие интересы! Теперь вы можете общаться.",
                related_user_id=user_id,
                related_entity_id=like.id,
                timestamp=datetime.utcnow()
            )
            session.add(notification)
            await session.commit()
            return like, reverse_like, notification
        else:
            reverse_like = Like(
                liker_id=user_id,
                liked_id=like.liker_id,
                status=LikeStatus.ACCEPTED,
                timestamp=datetime.utcnow()
            )
            session.add(reverse_like)

            liker = await session.get(User, user_id)
            notification = Notification(
                user_id=like.liker_id,
                type=NotificationType.MATCH_CREATED,
                content=f"У вас с {liker.name} схожие интересы! Теперь вы можете общаться.",
                related_user_id=user_id,
                related_entity_id=like.id,
                timestamp=datetime.utcnow()
            )
            session.add(notification)
            await session.commit()
            return like, reverse_like, notification
    else:
        # Decline the like
        like.status = LikeStatus.DECLINED
        await session.commit()
        return like, None, None


async def get_received_likes(
        session: AsyncSession, user_id: int, status: Optional[LikeStatus] = None
) -> List[Like]:
    if status:
        query = select(Like).where(
            and_(
                Like.liked_id == user_id,
                Like.status == status
            )
        ).order_by(Like.timestamp.desc())
    else:
        query = select(Like).where(
            Like.liked_id == user_id
        ).order_by(Like.timestamp.desc())

    result = await session.execute(query)
    return result.scalars().all()


async def get_sent_likes(
        session: AsyncSession, user_id: int, status: Optional[LikeStatus] = None
) -> List[Like]:
    if status:
        query = select(Like).where(
            and_(
                Like.liker_id == user_id,
                Like.status == status
            )
        ).order_by(Like.timestamp.desc())
    else:
        query = select(Like).where(
            Like.liker_id == user_id
        ).order_by(Like.timestamp.desc())

    result = await session.execute(query)
    return result.scalars().all()


async def get_matches(session: AsyncSession, user_id: int) -> List[Like]:
    query = select(Like).where(
        and_(
            Like.liker_id == user_id,
            Like.status == LikeStatus.ACCEPTED
        )
    ).order_by(Like.timestamp.desc())

    result = await session.execute(query)
    return result.scalars().all()


async def get_notifications(session: AsyncSession, user_id: int) -> Tuple[List[Notification], int]:
    query = select(Notification).where(
        Notification.user_id == user_id
    ).order_by(Notification.timestamp.desc())

    result = await session.execute(query)
    notifications = result.scalars().all()

    unread_count = sum(1 for n in notifications if not n.is_read)

    return notifications, unread_count


async def mark_as_read(session: AsyncSession, notification_id: int, user_id: int) -> bool:
    notification = await session.get(Notification, notification_id)
    if not notification or notification.user_id != user_id:
        return False

    notification.is_read = True
    await session.commit()
    return True


async def mark_all_as_read(session: AsyncSession, user_id: int) -> int:
    query = update(Notification).where(
        and_(
            Notification.user_id == user_id,
            Notification.is_read == False
        )
    ).values(is_read=True)

    result = await session.execute(query)
    await session.commit()
    return result.rowcount


# ./src/api_v1/like/dependencies.py


# ./src/api_v1/like/routes.py
from typing import Annotated, List

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.api_v1.auth.crud import get_current_active_user
from src.api_v1.like.schemas import (
    LikeCreate,
    LikeResponse,
    LikeAction,
    LikeStatus,
    NotificationResponse,
    NotificationsResponse
)
from src.api_v1.like import crud as like_crud
from src.core.database import User, postgres_helper, Notification

likes_router = APIRouter(prefix="/likes", tags=["Likes"])
notifications_router = APIRouter(prefix="/notifications", tags=["Notifications"])


@likes_router.post("", response_model=LikeResponse, status_code=status.HTTP_201_CREATED)
async def create_like(
        like_data: LikeCreate,
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    liked_user = await session.get(User, like_data.liked_id)
    if not liked_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found",
        )

    if current_user.id == like_data.liked_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="You cannot like yourself",
        )

    like, is_match, _ = await like_crud.create_like(
        session=session,
        liker_id=current_user.id,
        liked_id=like_data.liked_id
    )

    like.liker = current_user
    like.liked = liked_user

    return like


@likes_router.get("/received", response_model=List[LikeResponse])
async def get_received_likes(
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
        status: LikeStatus = None,
):

    likes = await like_crud.get_received_likes(
        session=session,
        user_id=current_user.id,
        status=status
    )

    for like in likes:
        if not like.liker:
            like.liker = await session.get(User, like.liker_id)

    return likes


@likes_router.get("/sent", response_model=List[LikeResponse])
async def get_sent_likes(
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
        status: LikeStatus = None,
):
    likes = await like_crud.get_sent_likes(
        session=session,
        user_id=current_user.id,
        status=status
    )

    for like in likes:
        if not like.liked:
            like.liked = await session.get(User, like.liked_id)

    return likes


@likes_router.get("/matches", response_model=List[LikeResponse])
async def get_matches(
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    likes = await like_crud.get_matches(
        session=session,
        user_id=current_user.id
    )

    for like in likes:
        if not like.liked:
            like.liked = await session.get(User, like.liked_id)

    return likes


@likes_router.post("/{like_id}/respond", response_model=LikeResponse)
async def respond_to_like(
        like_id: int,
        action: LikeAction,
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    accept = action.action == "accept"

    like, _, _ = await like_crud.respond_to_like(
        session=session,
        like_id=like_id,
        user_id=current_user.id,
        accept=accept
    )

    if not like:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Like not found or you're not authorized to respond to it",
        )

    if not like.liker:
        like.liker = await session.get(User, like.liker_id)

    return like


@notifications_router.get("", response_model=NotificationsResponse)
async def get_notifications(
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    notifications, unread_count = await like_crud.get_notifications(
        session=session,
        user_id=current_user.id
    )
    for notification in notifications:
        if notification.related_user_id and not notification.related_user:
            notification.related_user = await session.get(User, notification.related_user_id)

    return NotificationsResponse(
        notifications=notifications,
        unread_count=unread_count
    )


@notifications_router.post("/{notification_id}/read", response_model=NotificationResponse)
async def mark_notification_as_read(
        notification_id: int,
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    """Mark a notification as read."""
    success = await like_crud.mark_as_read(
        session=session,
        notification_id=notification_id,
        user_id=current_user.id
    )

    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Notification not found or you're not authorized to mark it as read",
        )

  
    notification = await session.get(Notification, notification_id)

    if notification.related_user_id and not notification.related_user:
        notification.related_user = await session.get(User, notification.related_user_id)

    return notification


@notifications_router.post("/read-all", status_code=status.HTTP_204_NO_CONTENT)
async def mark_all_notifications_as_read(
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    """Mark all notifications as read."""
    await like_crud.mark_all_as_read(
        session=session,
        user_id=current_user.id
    )


# ./src/api_v1/auth/__init__.py


# ./src/api_v1/auth/schemas.py
from pydantic import BaseModel, Field, EmailStr, ConfigDict


class UserBase(BaseModel):
    username: str
    email: EmailStr


class UserCreate(UserBase):
    password: str = Field(..., min_length=8)


class UserLogin(BaseModel):
    username: str
    password: str


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None


class UserResponse(UserBase):
    model_config = ConfigDict(from_attributes=True)

    id: int
    is_active: bool


# ./src/api_v1/auth/crud.py
from datetime import datetime, timedelta
from typing import Annotated, Union

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.api_v1.auth.schemas import TokenData
from src.core.data import settings
from src.core.database import User, postgres_helper

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login")


def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password):
    return pwd_context.hash(password)


async def get_user(username: str, session: AsyncSession):
    query = select(User).where(User.username == username)
    result = await session.execute(query)
    return result.scalar_one_or_none()


async def authenticate_user(username: str, password: str, session: AsyncSession):
    user = await get_user(username, session)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.secret_key, algorithm=settings.algorithm)
    return encoded_jwt


async def get_current_user(
    token: Annotated[str, Depends(oauth2_scheme)],
    session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.secret_key, algorithms=[settings.algorithm])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    user = await get_user(username=token_data.username, session=session)
    if user is None:
        raise credentials_exception
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)]
):
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

# ./src/api_v1/auth/dependencies.py


# ./src/api_v1/auth/routes.py
from datetime import timedelta
from typing import Annotated

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.api_v1.auth.schemas import Token, UserCreate, UserResponse
from src.api_v1.auth.crud import (
    authenticate_user,
    create_access_token,
    get_current_active_user,
    get_password_hash,
    get_user,
)
from src.core.data import settings
from src.core.database import User, postgres_helper

auth_router = APIRouter(prefix="/auth", tags=["Authentication"])


@auth_router.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def register(
        user_create: UserCreate,
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    existing_user = await get_user(user_create.username, session)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already registered",
        )
    query = select(User).where(User.email == user_create.email)
    result = await session.execute(query)
    
    if result.scalar_one_or_none():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered",
        )


    hashed_password = get_password_hash(user_create.password)
    new_user = User(
        username=user_create.username,
        email=user_create.email,
        hashed_password=hashed_password,
    )

    session.add(new_user)
    await session.commit()
    await session.refresh(new_user)

    return new_user


@auth_router.post("/login", response_model=Token)
async def login_for_access_token(
        form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    user = await authenticate_user(form_data.username, form_data.password, session)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    access_token_expires = timedelta(minutes=settings.access_token_expire_minutes)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )

    return {"access_token": access_token, "token_type": "bearer"}


@auth_router.get("/me", response_model=UserResponse)
async def read_users_me(
        current_user: Annotated[User, Depends(get_current_active_user)]
):
    return current_user


# ./src/api_v1/match/__init__.py


# ./src/api_v1/match/schemas.py
from datetime import datetime
from pydantic import BaseModel, ConfigDict

from src.api_v1.user.schemas import RoommateResponse


class MatchBase(BaseModel):
    user1_id: int
    user2_id: int
    timestamp: datetime


class MatchCreate(BaseModel):
    user_id: int


class MatchResponse(MatchBase):
    model_config = ConfigDict(from_attributes=True)
    id: int


class MatchWithUserResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: int
    timestamp: datetime
    roommate: RoommateResponse


class MatchesResponse(BaseModel):
    matches: list[MatchWithUserResponse]


# ./src/api_v1/match/crud.py


# ./src/api_v1/match/dependencies.py


# ./src/api_v1/match/routes.py
from datetime import datetime
from typing import Annotated, List

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.api_v1.auth.crud import get_current_active_user
from src.api_v1.match.schemas import MatchResponse, MatchWithUserResponse, MatchesResponse
from src.core.database import User, postgres_helper
from src.core.database.alchemy_models.match import Match

matches_router = APIRouter(prefix="/matches", tags=["Matches"])


@matches_router.post("/{roommate_id}", response_model=MatchResponse, status_code=status.HTTP_201_CREATED)
async def create_match(
        roommate_id: int,
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    query = select(User).where(User.id == roommate_id)
    result = await session.execute(query)
    roommate = result.scalar_one_or_none()

    if not roommate:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Roommate not found",
        )

    query = select(Match).where(
        (
                (Match.user1_id == current_user.id) & (Match.user2_id == roommate_id) |
                (Match.user1_id == roommate_id) & (Match.user2_id == current_user.id)
        )
    )
    result = await session.execute(query)
    existing_match = result.scalar_one_or_none()

    if existing_match:
        return existing_match

    new_match = Match(
        user1_id=current_user.id,
        user2_id=roommate_id,
        timestamp=datetime.utcnow(),
    )

    session.add(new_match)
    await session.commit()
    await session.refresh(new_match)

    return new_match


@matches_router.get("/", response_model=List[MatchWithUserResponse])
async def get_matches(
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    query = select(Match).where(
        (Match.user1_id == current_user.id) | (Match.user2_id == current_user.id)
    )
    result = await session.execute(query)
    matches = result.scalars().all()

    match_responses = []
    for match in matches:
        roommate_id = match.user2_id if match.user1_id == current_user.id else match.user1_id

        query = select(User).where(User.id == roommate_id)
        result = await session.execute(query)
        roommate = result.scalar_one_or_none()

        if roommate:
            match_response = MatchWithUserResponse(
                id=match.id,
                timestamp=match.timestamp,
                roommate=roommate
            )
            match_responses.append(match_response)

    return match_responses


@matches_router.delete("/{match_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_match(
        match_id: int,
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    query = select(Match).where(
        (Match.id == match_id) &
        ((Match.user1_id == current_user.id) | (Match.user2_id == current_user.id))
    )
    result = await session.execute(query)
    match = result.scalar_one_or_none()

    if not match:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Match not found",
        )

    await session.delete(match)
    await session.commit()


# ./src/api_v1/__init__.py


# ./src/api_v1/user/__init__.py


# ./src/api_v1/user/schemas.py
from pydantic import BaseModel, Field, EmailStr, ConfigDict


class ProfileBase(BaseModel):
    name: str | None = None
    age: int | None = None
    gender: str | None = None
    occupation: str | None = None
    avatar: str | None = None
    bio: str | None = None
    interests: list[str] | None = None
    cleanliness_level: int | None = Field(None, ge=1, le=5)
    sleep_habits: str | None = None
    rent_budget: int | None = None
    location: str | None = None
    smoking_preference: str | None = None
    pet_preference: str | None = None


class ProfileUpdate(ProfileBase):
    pass


class ProfileResponse(ProfileBase):
    id: int
    username: str
    email: EmailStr

    class Config:
        from_attributes = True


class RoommateResponse(ProfileBase):
    model_config = ConfigDict(from_attributes=True)

    id: int
    username: str


# ./src/api_v1/user/crud.py


# ./src/api_v1/user/dependencies.py


# ./src/api_v1/user/routes.py
from typing import Annotated, List

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.api_v1.auth.crud import get_current_active_user
from src.api_v1.user.schemas import ProfileResponse, ProfileUpdate, RoommateResponse
from src.core.database import User, postgres_helper
from src.core.database.alchemy_models.match import Match

users_router = APIRouter(prefix="/users", tags=["Users"])


@users_router.get("/me", response_model=ProfileResponse)
async def get_my_profile(
        current_user: Annotated[User, Depends(get_current_active_user)]
):
    return current_user


@users_router.put("/me", response_model=ProfileResponse)
async def update_my_profile(
        profile: ProfileUpdate,
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    for key, value in profile.model_dump(exclude_unset=True).items():
        setattr(current_user, key, value)

    await session.commit()
    await session.refresh(current_user)

    return current_user


@users_router.get("/roommates", response_model=List[RoommateResponse])
async def get_potential_roommates(
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):

    query = select(Match).where(
        ((Match.user1_id == current_user.id) | (Match.user2_id == current_user.id))
    )
    result = await session.execute(query)
    matches = result.scalars().all()

    matched_user_ids = []
    for match in matches:
        if match.user1_id == current_user.id:
            matched_user_ids.append(match.user2_id)
        else:
            matched_user_ids.append(match.user1_id)

    query = select(User).where(
        (User.id != current_user.id) &
        (~User.id.in_(matched_user_ids))
    )
    result = await session.execute(query)
    potential_roommates = result.scalars().all()

    return potential_roommates


# ./src/api_v1/ai_matching/__init__.py


# ./src/api_v1/ai_matching/schemas.py
from typing import List, Optional
from pydantic import BaseModel, Field

from src.api_v1.user.schemas import RoommateResponse


class CompatibilityScore(BaseModel):
    score: float = Field(..., ge=0, le=100, description="Compatibility score from 0-100")
    explanation: str = Field(..., description="Explanation of compatibility factors")


class AIMatchResponse(BaseModel):
    user: RoommateResponse
    compatibility_score: float = Field(..., ge=0, le=100)
    compatibility_explanation: str

    class Config:
        from_attributes = True


class AIMatchesRequest(BaseModel):
    limit: Optional[int] = Field(10, ge=1, le=50, description="Maximum number of matches to return")


class AIMatchesResponse(BaseModel):
    matches: List[AIMatchResponse]

    class Config:
        from_attributes = True

# ./src/api_v1/ai_matching/crud.py
from datetime import datetime, timedelta
from typing import Annotated, Union

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.api_v1.auth.schemas import TokenData
from src.core.data import settings
from src.core.database import User, postgres_helper

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login")


def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password):
    return pwd_context.hash(password)


async def get_user(username: str, session: AsyncSession):
    query = select(User).where(User.username == username)
    result = await session.execute(query)
    return result.scalar_one_or_none()


async def authenticate_user(username: str, password: str, session: AsyncSession):
    user = await get_user(username, session)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.secret_key, algorithm=settings.algorithm)
    return encoded_jwt


async def get_current_user(
    token: Annotated[str, Depends(oauth2_scheme)],
    session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.secret_key, algorithms=[settings.algorithm])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    user = await get_user(username=token_data.username, session=session)
    if user is None:
        raise credentials_exception
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)]
):
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

# ./src/api_v1/ai_matching/dependencies.py


# ./src/api_v1/ai_matching/routes.py
from typing import Annotated, List

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.api_v1.ai_matching.schemas import AIMatchesResponse, AIMatchResponse, CompatibilityScore
from src.core.utils.AIMatchingService import ai_matching_service
from src.api_v1.auth.crud import get_current_active_user
from src.core.database import User, postgres_helper
from src.core.database.alchemy_models.match import Match

ai_matching_router = APIRouter(prefix="/ai-matching", tags=["AI Matching"])


@ai_matching_router.get("/smart-matches", response_model=AIMatchesResponse)
async def get_ai_matches(
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
        limit: int = Query(10, ge=1, le=50),
):

    if not current_user.name or not current_user.bio or not current_user.interests:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Please complete your profile to get AI matches",
        )

    query = select(Match).where(
        ((Match.user1_id == current_user.id) | (Match.user2_id == current_user.id))
    )
    result = await session.execute(query)
    matches = result.scalars().all()

    matched_user_ids = []
    for match in matches:
        if match.user1_id == current_user.id:
            matched_user_ids.append(match.user2_id)
        else:
            matched_user_ids.append(match.user1_id)

    query = select(User).where(
        (User.id != current_user.id) &
        (~User.id.in_(matched_user_ids))
    )
    result = await session.execute(query)
    potential_matches = result.scalars().all()

    ai_matches = ai_matching_service.get_top_matches(
        current_user=current_user,
        potential_matches=potential_matches,
        limit=limit
    )

    matches_response = AIMatchesResponse(
        matches=[
            AIMatchResponse(
                user=match["user"],
                compatibility_score=match["compatibility_score"],
                compatibility_explanation=match["compatibility_explanation"]
            )
            for match in ai_matches
        ]
    )

    return matches_response


@ai_matching_router.get("/{user_id}/compatibility", response_model=CompatibilityScore)
async def get_compatibility_score(
        user_id: int,
        current_user: Annotated[User, Depends(get_current_active_user)],
        session: Annotated[AsyncSession, Depends(postgres_helper.session_dependency)],
):
    query = select(User).where(User.id == user_id)
    result = await session.execute(query)
    other_user = result.scalar_one_or_none()

    if not other_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found",
        )

    score, explanation = ai_matching_service.calculate_compatibility_score(
        current_user, other_user
    )

    return CompatibilityScore(score=score, explanation=explanation)

# ./src/core/database/alchemy_models/user.py
# src/core/database/alchemy_models/user.py
from sqlalchemy import Integer, String, Boolean, Float, ARRAY, Enum
from sqlalchemy.dialects.postgresql import JSON
from sqlalchemy.orm import Mapped, mapped_column
import enum

from src.core.database.alchemy_models.base import Base


class AccommodationPreference(str, enum.Enum):
    APARTMENT = "apartment"
    DORMITORY = "dormitory"
    NO_PREFERENCE = "no_preference"


class User(Base):
    username: Mapped[str] = mapped_column(unique=True)
    email: Mapped[str] = mapped_column(unique=True)
    hashed_password: Mapped[str]
    is_active: Mapped[bool] = mapped_column(default=True)
    is_superuser: Mapped[bool] = mapped_column(default=False)

    # Custom user metadata (for telegram info etc)
    user_metadata: Mapped[dict] = mapped_column(JSON, nullable=True)

    # Basic profile info
    name: Mapped[str] = mapped_column(nullable=True)
    age: Mapped[int] = mapped_column(Integer, nullable=True)
    gender: Mapped[str] = mapped_column(nullable=True)
    occupation: Mapped[str] = mapped_column(nullable=True)
    avatar: Mapped[str] = mapped_column(nullable=True)
    bio: Mapped[str] = mapped_column(nullable=True)
    interests: Mapped[list[str]] = mapped_column(ARRAY(String), nullable=True)

    # Living preferences
    cleanliness_level: Mapped[int] = mapped_column(Integer, nullable=True)
    sleep_habits: Mapped[str] = mapped_column(nullable=True)
    rent_budget: Mapped[int] = mapped_column(Integer, nullable=True)
    location: Mapped[str] = mapped_column(nullable=True)
    smoking_preference: Mapped[str] = mapped_column(nullable=True)
    pet_preference: Mapped[str] = mapped_column(nullable=True)

    # New fields for education and accommodation
    study_location: Mapped[str] = mapped_column(nullable=True)
    study_program: Mapped[str] = mapped_column(nullable=True)
    accommodation_preference: Mapped[str] = mapped_column(
        Enum(AccommodationPreference, native_enum=False),
        nullable=True
    )

    # Telegram contact info (for matches)
    telegram_username: Mapped[str] = mapped_column(nullable=True)

# ./src/core/database/alchemy_models/notification.py
from datetime import datetime
from enum import Enum as PyEnum
from sqlalchemy import ForeignKey, String, DateTime, Enum, Boolean
from sqlalchemy.orm import Mapped, mapped_column, relationship

from src.core.database.alchemy_models.base import Base


class NotificationType(str, PyEnum):
    NEW_LIKE = "new_like"
    MATCH_CREATED = "match_created"
    NEW_MESSAGE = "new_message"


class Notification(Base):
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
    type: Mapped[NotificationType] = mapped_column(Enum(NotificationType))
    content: Mapped[str] = mapped_column(String)
    related_user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=True)
    related_entity_id: Mapped[int] = mapped_column(nullable=True)
    is_read: Mapped[bool] = mapped_column(Boolean, default=False)
    timestamp: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    user = relationship("User", foreign_keys=[user_id], backref="notifications")
    related_user = relationship("User", foreign_keys=[related_user_id])


# ./src/core/database/alchemy_models/like.py
from datetime import datetime
from enum import Enum as PyEnum
from sqlalchemy import ForeignKey, String, DateTime, Enum, Boolean
from sqlalchemy.orm import Mapped, mapped_column, relationship

from src.core.database.alchemy_models.base import Base


class LikeStatus(str, PyEnum):
    PENDING = "pending"
    ACCEPTED = "accepted"
    DECLINED = "declined"


class Like(Base):
    liker_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
    liked_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
    status: Mapped[LikeStatus] = mapped_column(
        Enum(LikeStatus), default=LikeStatus.PENDING
    )
    timestamp: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    liker = relationship("User", foreign_keys=[liker_id], backref="likes_given")
    liked = relationship("User", foreign_keys=[liked_id], backref="likes_received")


# ./src/core/database/alchemy_models/__init__.py


# ./src/core/database/alchemy_models/base.py
from sqlalchemy.orm import DeclarativeBase, Mapped, declared_attr, mapped_column


class Base(DeclarativeBase):
    __abstract__ = True

    @declared_attr
    def __tablename__(cls) -> str:
        return f"{cls.__name__.lower()}s"

    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)


# ./src/core/database/alchemy_models/match.py
from datetime import datetime
from sqlalchemy import ForeignKey, DateTime
from sqlalchemy.orm import Mapped, mapped_column, relationship

from src.core.database.alchemy_models.base import Base


class Match(Base):
    user1_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
    user2_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
    timestamp: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    user1 = relationship("User", foreign_keys=[user1_id], backref="matches_as_user1")
    user2 = relationship("User", foreign_keys=[user2_id], backref="matches_as_user2")


# ./src/core/database/__init__.py
__all__ = (
    "postgres_helper",
    "Base",
    "User",
    "Match",
    "Like",
    "Notification",
)

from src.core.database.alchemy_models.base import Base
from src.core.database.alchemy_models.like import Like
from src.core.database.alchemy_models.match import Match
from src.core.database.alchemy_models.notification import Notification
from src.core.database.alchemy_models.user import User
from src.core.database.helpers.postgres_helper import postgres_helper


# ./src/core/database/helpers/__init__.py


# ./src/core/database/helpers/postgres_helper.py
from asyncio import current_task

from sqlalchemy.ext.asyncio import (
    AsyncSession,
    async_scoped_session,
    async_sessionmaker,
    create_async_engine,
)

from src.core.data import settings


class DatabaseHelper:
    def __init__(self, url: str, echo: bool = False):
        self.engine = create_async_engine(
            url=url,
            echo=echo,
            pool_size=10,
            max_overflow=20,
            pool_timeout=60,
            pool_recycle=1800,
        )
        self.session_factory = async_sessionmaker(
            bind=self.engine,
            autoflush=False,
            autocommit=False,
            expire_on_commit=False,
        )

    async def get_scoped_session(self):
        session = async_scoped_session(
            session_factory=self.session_factory,
            scopefunc=current_task,
        )
        return session

    async def session_dependency(self) -> AsyncSession:
        async with self.session_factory() as session:
            yield session
            await session.close()

    async def scoped_session_dependency(self) -> AsyncSession:
        session = await self.get_scoped_session()
        try:
            yield session
        finally:
            await session.close()


postgres_helper = DatabaseHelper(
    url=settings.db_url,
    echo=settings.db_echo,
)


# ./src/core/__init__.py


# ./src/core/utils/AIMatchingService.py
import os
import json
from typing import List, Dict, Any, Tuple

from yandex_cloud_ml_sdk import YCloudML

from bot.config import YANDEX_FOLDER_ID, YANDEX_API_KEY
from src.core.database.alchemy_models.user import User


class AIMatchingService:
    def __init__(self):
        self.sdk = YCloudML(
            folder_id=YANDEX_FOLDER_ID,
            auth=YANDEX_API_KEY,
        )
        self.model = self.sdk.models.completions('yandexgpt-lite')
        self.model.configure(
            temperature=0.3,
            max_tokens=2000,
        )

    def calculate_compatibility_score(self, user1: User, user2: User) -> Tuple[float, str]:
        system_prompt = (
            "You are an expert roommate matching algorithm. Analyze two potential roommates' "
            "profiles and calculate a compatibility score from 0-100 based on their preferences. "
            "Return a JSON object with 'score' (number) and 'explanation' (string) fields."
        )

        user_data = {
            "user1": {
                "age": user1.age,
                "gender": user1.gender,
                "occupation": user1.occupation,
                "bio": user1.bio,
                "interests": user1.interests or [],
                "cleanliness_level": user1.cleanliness_level,
                "sleep_habits": user1.sleep_habits,
                "rent_budget": user1.rent_budget,
                "location": user1.location,
                "smoking_preference": user1.smoking_preference,
                "pet_preference": user1.pet_preference
            },
            "user2": {
                "age": user2.age,
                "gender": user2.gender,
                "occupation": user2.occupation,
                "bio": user2.bio,
                "interests": user2.interests or [],
                "cleanliness_level": user2.cleanliness_level,
                "sleep_habits": user2.sleep_habits,
                "rent_budget": user2.rent_budget,
                "location": user2.location,
                "smoking_preference": user2.smoking_preference,
                "pet_preference": user2.pet_preference
            }
        }

        user_prompt = f"Analyze these two potential roommates for compatibility:\n{json.dumps(user_data, indent=2)}"

        messages = [
            {'role': 'system', 'text': system_prompt},
            {'role': 'user', 'text': user_prompt},
        ]

        operation = self.model.run_deferred(messages)
        result = operation.wait()

        try:
            ai_response = json.loads(result.text)
            score = float(ai_response.get('score', 50))
            explanation = ai_response.get('explanation', "No explanation provided")
            return (score, explanation)
        except (json.JSONDecodeError, ValueError):
            # If we can't parse the response, return a default score
            return (50, "Could not analyze compatibility - using default score")

    def get_top_matches(self, current_user: User, potential_matches: List[User], limit: int = 10) -> list[
        dict[str, Any]]:
        matches = []

        for potential_match in potential_matches:
            if potential_match.id == current_user.id:
                continue

            score, explanation = self.calculate_compatibility_score(current_user, potential_match)

            matches.append({
                "user": potential_match,
                "compatibility_score": score,
                "compatibility_explanation": explanation
            })

        matches.sort(key=lambda x: x["compatibility_score"], reverse=True)

        return matches[:limit]


ai_matching_service = AIMatchingService()

# ./src/core/utils/__init__.py


# ./src/core/data/config.py
from functools import lru_cache
from pathlib import Path

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    db_url: str
    db_echo: bool = False

    secret_key: str
    algorithm: str
    access_token_expire_minutes: int

    yandex_folder_id: str
    yandex_api_key: str
    telegram_bot_token: str

    model_config = SettingsConfigDict(env_file=".env")


@lru_cache
def get_settings():
    return Settings()


settings = get_settings()


# ./src/core/data/__init__.py
__all__ = ("settings",)

from src.core.data.config import settings


# ./src/__init__.py


# ./src/main.py
from contextlib import asynccontextmanager

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from scalar_fastapi import get_scalar_api_reference
from starlette.middleware.sessions import SessionMiddleware

from src.api_v1.ai_matching.routes import ai_matching_router
from src.api_v1.auth.routes import auth_router
from src.api_v1.like.routes import likes_router, notifications_router
from src.api_v1.match.routes import matches_router
from src.api_v1.user.routes import users_router


@asynccontextmanager
async def lifespan(app: FastAPI):
    yield


app = FastAPI(root_path="/api/v1", lifespan=lifespan, debug=True)
app.include_router(
    users_router
)
app.include_router(
    auth_router
)
app.include_router(
    matches_router
)
app.include_router(ai_matching_router)
app.include_router(likes_router)
app.include_router(notifications_router)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/scalar", include_in_schema=False)
async def scalar_html():
    return get_scalar_api_reference(
        openapi_url=app.openapi_url,
        title=app.title,
    )


app.add_middleware(SessionMiddleware, secret_key="123")


